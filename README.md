# Docker_study
### 도커는 애플리케이션 실행 환경을 패키징하여, 어디서든 동일하게 실행할 수 있게 해주는 가상화 플랫폼이다.
<br>

## 2장. 도커의 기본적인 사용법
```
docker container run 
```
> 컨테이너로 애플리케이션을 실행하라는 도커 명령
#
**빌드** : 소스 코드를 컴파일해 실행 가능한 프로그램으로 만드는 과정  
**공유** : 이 빌드 결과물을 다른 개발자, 서버, 또는 테스트 환경에 전달하는 것  
**실행** : 공유된 빌드를 실제로 테스트하거나 배포하여 실행하는 것  

* 컨테이너를 실행할 때마다 컴퓨터 이름과 IP 주소가 매번 바뀐다.
* 컨테이너는 '격리'와 '밀집'이라는 두 가지 조건을 모두 만족시킬 수 있다. 밀집이란 컴퓨터에 CPU와 메모리가 허용하는 한 되도록
  많은 수의 애플리케이션을 실행하는 것을 의미한다. 한편, 애플리케이션은 서로 독립된 환경에서 실행돼야 한다.

* 도커를 사용하면 도구와 스크립트를 하나의 이미지로 패키징해 추가적인 설치나 설정 작업 없이 컨테이너로 스크립트를 바로 실행하게 할 수 있다.

```
docker container ls
```
> 현재 실행 중인 모든 컨테이너에 대한 정보를 볼 수 있다.
#
* 컨테이너는 종료되어도 사라지지 않는다.

- 도커를 설치하면 호스트 컴퓨터의 네트워크 계층에 도커가 끼어들게 되는데, 그러면 호스트 컴퓨터에서 들고나는 네트워크 트래픽을 모두 도커가 가로채서
  그중 필요한 것을 컨테이너에 전달할 수 있다.

* 도커 엔진은 도커의 관리 기능을 맡는 컴포넌트다. 로컬 이미지 캐시를 담당하므로 새로운 이미지가 필요하면 이미지를 내려받으며, 기존 이미지가 있다면 전에 내려받은 이미지를 사용한다.
  항시 동작하는 백그라운드 프로세스이다.

* 도커 API는 표준 HTTP 기반 REST API다. 도커 엔진의 설정을 수정하면 이 API를 네트워크를 경유해 외부 컴퓨터로부터 호출할 수 없도록 차단하거나 허용할 수 있다.
* 도커 명령행 인터페이스(도커 CLI)는 도커 API의 클라이언트다. (실제로 도커 API를 호출하는 것)

## 연습문제
* 앞서 실행해 봤던 웹 사이트 컨테이너를 실행하고 index.html 파일을 교체해 웹 페이지의 내용을 수정하는 것이다.
```
docker container run --detach --publish 8088:80 diamol/ch02-hello-diamol-web
docker container ls // container ID 확인 (0f4ad828824b)
docker exec -it 0f4ad828824b /bin/sh
```
컨테이너 안의 쉘 환경으로 접속후
```
cd /usr/local/apache2/htdocs
vi index.html
index.html 코드 수정
```
#

## 3장. 도커 이미지 만들기
* 도커 이미지는 물리적으로는 여러 개의 작은 파일로 구성돼 있다. 도커가 이들 파일을 조립해 컨테이너의 내부 파일 시스템을 만든다. 모든 레이어를 내려받고 나면
  전체 이미지를 사용할 수 있게 된다.
* --name : 지금까지 컨테이너를 조작하려면 임의로 생성된 컨테이너 ID를 입력해 대상 컨테이너를 지정해 주어야 했다. 그러나 --name 플래그를 사용하면 컨테이너에 원하는
  이름을 붙이고 이 이름으로 컨테이너를 지칭할 수 있다.

* Dockerfile은 애플리케이션을 패키징하기 위한 간단한 스크립트이다.
  1. FROM : 모든 이미지는 다른 이미지로부터 출발한다.
  2. ENV : 환경 변수 값을 지정하기 위한 인스트럭션. 값을 지정하기 위해 [key]="[value]" 형식을 따른다.
  3. WORKDIR : 컨테이너 이미지 파일 시스템에 디렉터리를 만들고, 해당 디렉터리를 작업 디렉터리로 지정하는 인스트럭션.
  4. COPY : 로컬 파일 시스템의 파일 혹은 디렉터리를 컨테이너 이미지로 복사하는 인스트럭션. [원본경로] [복사경로] 형식으로 지정하면 된다.
  5. CMD : 도커가 이미지로부터 컨테이너를 실행했을 때 실행할 명령을 지정하는 인스트럭션이다.
#
### 3.3 컨테이너 이미지 빌드하기
* 이미지를 빌드하려면 Dockerfile 스크립트 외에도 필요한 것이 몇 가지 더 있다. 이미지의 이름, 패키징에 필요한 파일의 경로를 추가로 지정해 주어야 한다.
* build 명령을 입력하면 Dockerfile 스크립트에 포함된 인스트럭션이 차례로 실행되며 그 결과가 출력된다.
#
### 3.4 도커 이미지와 이미지 레이어 이해하기
* 도커 이미지는 이미지 레이어가 모인 논리적 대상이다. 레이어는 도커 엔진의 캐시에 물리적으로 저장된 파일이다. 이미지 레이어는 여러 이미지와 컨테이너에서 공유된다.
* 도커에서 이미지 캐시의 실제 디스크 용량(물리적 용량)은 논리적 용량보다 작을 수 있다. 레이어 구조와 중복제거 기술을 활용하여 공간을 절약하기 때문이다.
  > 도커의 이미지 레이어는 여러 이미지와 컨테이너에서 공유될 수 있기 때문에, 중복되는 레이어는 디스크에 한 번만 저장되고, 그로 인해 실질적인 저장 용량은 논리적인 합계보다 더 작다.
* 이미지 레이어를 여러 이미지가 공유한다면, 공유되는 레이어는 수정할 수 없어야 한다.

### 3.5 이미지 레이어 캐시를 이용한 Dockerfile 스크립트 최적화
* Dockerfile 스크립트의 인스트럭션은 각각 하나의 이미지 레이어와 1:1로 연결된다. 그러나 인스트럭션의 결과가 이전 빌드와 같다면, 이전에 캐시된 레이어를 재사용한다.
  이런 방법으로 똑같은 인스트럭션을 다시 실행하는 낭비를 줄일 수 있다.

* 도커는 캐시에 일치하는 레이어가 있는지 확인하기 위해 해시값을 이용한다. 해시값은 Dockerfile 스크립트의 인스트럭션과 인스트럭션에 의해 복사되는 파일의 내용으로부터 계산되는데, 기존 이미지 레이어에
  해시값이 일치하는 것이 없다면 캐시 미스가 발생하고 해당 인스트럭션이 실행된다. 한 번 인스트럭션이 실행되면 그 다음에 오는 인스트럭션은 수정된 것이 없더라도 모두 실행된다.
  > 이러한 이유로 Dockerfile 스크립트의 인스트럭션은 잘 수정하지 않는 인스트럭션이 앞으로 오고 자주 수정되는 인스트럭션이 뒤에 오도록 배치돼야 한다. 이렇게 해야 캐시에 저장된 이미지 레이어를 되도록 많이 재사용할 수 있다.

## 연습문제
* Dockerfile 스크립트 없이 도커 이미지를 만들어보자. Dockerfile의 목적은 애플리케이션 배포를 자동화하는 것이다. 그러나 때로는 자동화 없이 수동으로 직접 해야 하거나, 스크립트로 작성할 수 없는 절차가 필요한 경우가 있다.
```
docker container run -it --name ch03lab diamol/ch03-lab
echo Hyeonuk >> cho03.txt
exit
docker container commit ch03lab ch03-lab-soln
docker container run ch03-lab-soln cat ch03.txt
```
#

## 4장. 애플리케이션 소스 코드에서 도커 이미지까지
* RUN 인스트럭션은 빌드 중에 컨테이너 안에서 명령을 실행한 다음 그 결과를 이미지 레이어에 저장하는 기능을 한다.
#
* 멀티 스테이지 Dockerfile 스크립트의 동작 원리와 컨테이너 안에서 애플리케이션을 빌드하는 것이 유용한 이유
  1. 표준화. 모든 빌드 과정은 도커 컨테이너 내부에서 이뤄진다. 따라서 도구 버전의 차이로 인한 빌드 실패를 줄일       수 있다.
  2. 성능 향상. 멀티 스테이지 빌드의 각 단계는 자신만의 캐시를 따로 갖는다. 그리고 도커는 빌드 중에 각 인스트럭션에 해당하는 레이어 캐시를 찾는다.
     해당되는 캐시를 찾지 못하면 남은 인스트럭션이 모두 실행되지만, 그 범위가 해당 단계 안으로 국한된다. 이어지는 다음 단계는 다시 캐시를 재사용하면서 시작할 수 있다.
  3. 최종 산출물인 이미지를 가능한 작게 유지할 수 있다. 최종 산출물인 이미지에 불필요한 도구는 빼버릴 수 있다. 이러한 방법으로 이미지 크기를 줄여서 애플리케이션의
     시작 시간을 단축할 수 있으며, 애플리케이션의 의존 모듈 자체를 줄여 취약점을 이용한 외부 공격의 가능성도 최대한 차단할 수 있다.

## 연습문제
* 지금 있는 Dockerfile 스크립트로 이미지를 빌드한다. 이어서 Dockerfile 스크립트를 최적화한 다음 새로운 이미지를 빌드하라.
* 현재 이미지는 리눅스 환경에서 약 800MB, 윈도 환경에서 약 5.2GB 크기다. 최적화된 이미지의 크기가 리눅스 환경에서 약 15MB, 윈도 환경에서 약 260MB가 되도록 하라.
* 현재 Dockerfile 스크립트에 포함된 HTML 파일의 내용을 수정하면 일곱 단계의 빌드 단계를 재수행한다.
* Dockerfile 스크립트를 최적화해서 HTML 파일을 수정하더라도 재수행하는 빌드 단계가 한 단계가 되도록 하라.

```
docker image build -t ch04-lab:optimized -f Dockerfile.optimized .
docker container run -d -p 805:80 ch04-lab:optimized
image is 15MB on Linux; 230MB on Windows
```
#
### 5장. 도커 허브 등 레지스트리에 이미지 공유하기
```
docker.io/diamol/golang:latest
```
docker.io : 이미지가 저장된 레지스트리의 도메인. 기본값은 도커 허브다.<br>
diamol : 이미지 작성자의 계정 이름. 개인 혹은 단체의 이름에 해당한다.<br>
golang : 이미지 리포지터리 이름. 일반적으로 애플리케이션의 이름에 해당한다. 하나의 리포지터리는 여러 버전의 이미지를 담을 수 있다.<br>
latest : 이미지 태그. 애플리케이션의 버전 혹은 변종을 나타낸다. 기본값은 latest다.
* 레지스트리를 통해 다른 사람이 이미지를 사용하게 하려면 좀 더 상세한 정보를 이미지 이름에 포함시켜야 한다. 바로 이 이미지 참조가
  레지스트리에서 특정한 이미지를 식별하는 식별자 역할을 하기 때문이다.
#
```
docker container run -d -p 5000:5000 --restart always diamol/registry
```
| 옵션 | 의미 |
|------|------|
| `docker container run` | 새 컨테이너를 실행하겠다는 뜻 |
| `-d` | **detach 모드**: 터미널에 묶이지 않고 백그라운드로 실행 |
| `-p 5000:5000` | **포트 매핑**: 로컬 컴퓨터의 `5000` 포트를 컨테이너의 `5000` 포트에 연결 |
| `--restart always` | 시스템이 재부팅되거나 컨테이너가 꺼져도 **자동 재시작** |
| `diamol/registry` | 사용할 **이미지 이름** (여기선 레지스트리 서버 이미지) |
#
* 골든 이미지 : 공식 이미지를 기반 이미지로 삼아 인증서나 환경 설정값 등 자신이 필요한 설정을 추가한 것.
#
### 6장. 도커 볼륨을 이용한 퍼시스턴트 스토리지
* 컨테이너의 디스크 역시 이 이미지 레이어를 순서대로 합쳐 만든 가상 파일 시스템이다.
* 모든 컨테이너는 독립된 파일 시스템을 갖는다. 같은 이미지에서 실행한 여러 개의 컨테이너는 처음에는 디스크의 내용이 모두 같지만,
  그중 한 컨테이너에서 애플리케이션이 파일을 수정해도 다른 컨테이너나 이미지는 영향을 받지 않는다.

```
docker container run --name rn1 diamol/ch06-random-number
docker container run --name rn2 diamol/ch06-random-number

docker container cp rn1:/random/number.txt number1.txt
docker container cp rn2:/random/number.txt number2.txt

cat number1.txt
cat number2.txt
```
