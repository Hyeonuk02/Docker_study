# Docker_study
### 도커는 애플리케이션 실행 환경을 패키징하여, 어디서든 동일하게 실행할 수 있게 해주는 가상화 플랫폼이다.
<br>

## 2장. 도커의 기본적인 사용법
```
docker container run 
```
> 컨테이너로 애플리케이션을 실행하라는 도커 명령
#
**빌드** : 소스 코드를 컴파일해 실행 가능한 프로그램으로 만드는 과정  
**공유** : 이 빌드 결과물을 다른 개발자, 서버, 또는 테스트 환경에 전달하는 것  
**실행** : 공유된 빌드를 실제로 테스트하거나 배포하여 실행하는 것  

* 컨테이너를 실행할 때마다 컴퓨터 이름과 IP 주소가 매번 바뀐다.
* 컨테이너는 '격리'와 '밀집'이라는 두 가지 조건을 모두 만족시킬 수 있다. 밀집이란 컴퓨터에 CPU와 메모리가 허용하는 한 되도록
  많은 수의 애플리케이션을 실행하는 것을 의미한다. 한편, 애플리케이션은 서로 독립된 환경에서 실행돼야 한다.

* 도커를 사용하면 도구와 스크립트를 하나의 이미지로 패키징해 추가적인 설치나 설정 작업 없이 컨테이너로 스크립트를 바로 실행하게 할 수 있다.

```
docker container ls
```
> 현재 실행 중인 모든 컨테이너에 대한 정보를 볼 수 있다.
#
* 컨테이너는 종료되어도 사라지지 않는다.

- 도커를 설치하면 호스트 컴퓨터의 네트워크 계층에 도커가 끼어들게 되는데, 그러면 호스트 컴퓨터에서 들고나는 네트워크 트래픽을 모두 도커가 가로채서
  그중 필요한 것을 컨테이너에 전달할 수 있다.

* 도커 엔진은 도커의 관리 기능을 맡는 컴포넌트다. 로컬 이미지 캐시를 담당하므로 새로운 이미지가 필요하면 이미지를 내려받으며, 기존 이미지가 있다면 전에 내려받은 이미지를 사용한다.
  항시 동작하는 백그라운드 프로세스이다.

* 도커 API는 표준 HTTP 기반 REST API다. 도커 엔진의 설정을 수정하면 이 API를 네트워크를 경유해 외부 컴퓨터로부터 호출할 수 없도록 차단하거나 허용할 수 있다.
* 도커 명령행 인터페이스(도커 CLI)는 도커 API의 클라이언트다. (실제로 도커 API를 호출하는 것)

## 연습문제
* 앞서 실행해 봤던 웹 사이트 컨테이너를 실행하고 index.html 파일을 교체해 웹 페이지의 내용을 수정하는 것이다.
```
docker container run --detach --publish 8088:80 diamol/ch02-hello-diamol-web
docker container ls // container ID 확인 (0f4ad828824b)
docker exec -it 0f4ad828824b /bin/sh
```
컨테이너 안의 쉘 환경으로 접속후
```
cd /usr/local/apache2/htdocs
vi index.html
index.html 코드 수정
```
#

## 3장. 도커 이미지 만들기
* 도커 이미지는 물리적으로는 여러 개의 작은 파일로 구성돼 있다. 도커가 이들 파일을 조립해 컨테이너의 내부 파일 시스템을 만든다. 모든 레이어를 내려받고 나면
  전체 이미지를 사용할 수 있게 된다.
* --name : 지금까지 컨테이너를 조작하려면 임의로 생성된 컨테이너 ID를 입력해 대상 컨테이너를 지정해 주어야 했다. 그러나 --name 플래그를 사용하면 컨테이너에 원하는
  이름을 붙이고 이 이름으로 컨테이너를 지칭할 수 있다.

* Dockerfile은 애플리케이션을 패키징하기 위한 간단한 스크립트이다.
  1. FROM : 모든 이미지는 다른 이미지로부터 출발한다.
  2. ENV : 환경 변수 값을 지정하기 위한 인스트럭션. 값을 지정하기 위해 [key]="[value]" 형식을 따른다.
  3. WORKDIR : 컨테이너 이미지 파일 시스템에 디렉터리를 만들고, 해당 디렉터리를 작업 디렉터리로 지정하는 인스트럭션.
  4. COPY : 로컬 파일 시스템의 파일 혹은 디렉터리를 컨테이너 이미지로 복사하는 인스트럭션. [원본경로] [복사경로] 형식으로 지정하면 된다.
  5. CMD : 도커가 이미지로부터 컨테이너를 실행했을 때 실행할 명령을 지정하는 인스트럭션이다.
#
### 3.3 컨테이너 이미지 빌드하기
* 이미지를 빌드하려면 Dockerfile 스크립트 외에도 필요한 것이 몇 가지 더 있다. 이미지의 이름, 패키징에 필요한 파일의 경로를 추가로 지정해 주어야 한다.
* build 명령을 입력하면 Dockerfile 스크립트에 포함된 인스트럭션이 차례로 실행되며 그 결과가 출력된다.
#
### 3.4 도커 이미지와 이미지 레이어 이해하기
* 도커 이미지는 이미지 레이어가 모인 논리적 대상이다. 레이어는 도커 엔진의 캐시에 물리적으로 저장된 파일이다. 이미지 레이어는 여러 이미지와 컨테이너에서 공유된다.
* 도커에서 이미지 캐시의 실제 디스크 용량(물리적 용량)은 논리적 용량보다 작을 수 있다. 레이어 구조와 중복제거 기술을 활용하여 공간을 절약하기 때문이다.
  > 도커의 이미지 레이어는 여러 이미지와 컨테이너에서 공유될 수 있기 때문에, 중복되는 레이어는 디스크에 한 번만 저장되고, 그로 인해 실질적인 저장 용량은 논리적인 합계보다 더 작다.
* 이미지 레이어를 여러 이미지가 공유한다면, 공유되는 레이어는 수정할 수 없어야 한다.

### 3.5 이미지 레이어 캐시를 이용한 Dockerfile 스크립트 최적화
* Dockerfile 스크립트의 인스트럭션은 각각 하나의 이미지 레이어와 1:1로 연결된다. 그러나 인스트럭션의 결과가 이전 빌드와 같다면, 이전에 캐시된 레이어를 재사용한다.
  이런 방법으로 똑같은 인스트럭션을 다시 실행하는 낭비를 줄일 수 있다.

* 도커는 캐시에 일치하는 레이어가 있는지 확인하기 위해 해시값을 이용한다. 해시값은 Dockerfile 스크립트의 인스트럭션과 인스트럭션에 의해 복사되는 파일의 내용으로부터 계산되는데, 기존 이미지 레이어에
  해시값이 일치하는 것이 없다면 캐시 미스가 발생하고 해당 인스트럭션이 실행된다. 한 번 인스트럭션이 실행되면 그 다음에 오는 인스트럭션은 수정된 것이 없더라도 모두 실행된다.
  > 이러한 이유로 Dockerfile 스크립트의 인스트럭션은 잘 수정하지 않는 인스트럭션이 앞으로 오고 자주 수정되는 인스트럭션이 뒤에 오도록 배치돼야 한다. 이렇게 해야 캐시에 저장된 이미지 레이어를 되도록 많이 재사용할 수 있다.

## 연습문제
* Dockerfile 스크립트 없이 도커 이미지를 만들어보자. Dockerfile의 목적은 애플리케이션 배포를 자동화하는 것이다. 그러나 때로는 자동화 없이 수동으로 직접 해야 하거나, 스크립트로 작성할 수 없는 절차가 필요한 경우가 있다.
```
docker container run -it --name ch03lab diamol/ch03-lab
echo Hyeonuk >> cho03.txt
exit
docker container commit ch03lab ch03-lab-soln
docker container run ch03-lab-soln cat ch03.txt
```
#

## 4장. 애플리케이션 소스 코드에서 도커 이미지까지
* RUN 인스트럭션은 빌드 중에 컨테이너 안에서 명령을 실행한 다음 그 결과를 이미지 레이어에 저장하는 기능을 한다.
#
* 멀티 스테이지 Dockerfile 스크립트의 동작 원리와 컨테이너 안에서 애플리케이션을 빌드하는 것이 유용한 이유
  1. 표준화. 모든 빌드 과정은 도커 컨테이너 내부에서 이뤄진다. 따라서 도구 버전의 차이로 인한 빌드 실패를 줄일       수 있다.
  2. 성능 향상. 멀티 스테이지 빌드의 각 단계는 자신만의 캐시를 따로 갖는다. 그리고 도커는 빌드 중에 각 인스트럭션에 해당하는 레이어 캐시를 찾는다.
     해당되는 캐시를 찾지 못하면 남은 인스트럭션이 모두 실행되지만, 그 범위가 해당 단계 안으로 국한된다. 이어지는 다음 단계는 다시 캐시를 재사용하면서 시작할 수 있다.
  3. 최종 산출물인 이미지를 가능한 작게 유지할 수 있다. 최종 산출물인 이미지에 불필요한 도구는 빼버릴 수 있다. 이러한 방법으로 이미지 크기를 줄여서 애플리케이션의
     시작 시간을 단축할 수 있으며, 애플리케이션의 의존 모듈 자체를 줄여 취약점을 이용한 외부 공격의 가능성도 최대한 차단할 수 있다.

## 연습문제
* 지금 있는 Dockerfile 스크립트로 이미지를 빌드한다. 이어서 Dockerfile 스크립트를 최적화한 다음 새로운 이미지를 빌드하라.
* 현재 이미지는 리눅스 환경에서 약 800MB, 윈도 환경에서 약 5.2GB 크기다. 최적화된 이미지의 크기가 리눅스 환경에서 약 15MB, 윈도 환경에서 약 260MB가 되도록 하라.
* 현재 Dockerfile 스크립트에 포함된 HTML 파일의 내용을 수정하면 일곱 단계의 빌드 단계를 재수행한다.
* Dockerfile 스크립트를 최적화해서 HTML 파일을 수정하더라도 재수행하는 빌드 단계가 한 단계가 되도록 하라.

```
docker image build -t ch04-lab:optimized -f Dockerfile.optimized .
docker container run -d -p 805:80 ch04-lab:optimized
image is 15MB on Linux; 230MB on Windows
```
#
## 5장. 도커 허브 등 레지스트리에 이미지 공유하기
```
docker.io/diamol/golang:latest
```
docker.io : 이미지가 저장된 레지스트리의 도메인. 기본값은 도커 허브다.<br>
diamol : 이미지 작성자의 계정 이름. 개인 혹은 단체의 이름에 해당한다.<br>
golang : 이미지 리포지터리 이름. 일반적으로 애플리케이션의 이름에 해당한다. 하나의 리포지터리는 여러 버전의 이미지를 담을 수 있다.<br>
latest : 이미지 태그. 애플리케이션의 버전 혹은 변종을 나타낸다. 기본값은 latest다.
* 레지스트리를 통해 다른 사람이 이미지를 사용하게 하려면 좀 더 상세한 정보를 이미지 이름에 포함시켜야 한다. 바로 이 이미지 참조가
  레지스트리에서 특정한 이미지를 식별하는 식별자 역할을 하기 때문이다.
#
```
docker container run -d -p 5000:5000 --restart always diamol/registry
```
| 옵션 | 의미 |
|------|------|
| `docker container run` | 새 컨테이너를 실행하겠다는 뜻 |
| `-d` | **detach 모드**: 터미널에 묶이지 않고 백그라운드로 실행 |
| `-p 5000:5000` | **포트 매핑**: 로컬 컴퓨터의 `5000` 포트를 컨테이너의 `5000` 포트에 연결 |
| `--restart always` | 시스템이 재부팅되거나 컨테이너가 꺼져도 **자동 재시작** |
| `diamol/registry` | 사용할 **이미지 이름** (여기선 레지스트리 서버 이미지) |
#
* 골든 이미지 : 공식 이미지를 기반 이미지로 삼아 인증서나 환경 설정값 등 자신이 필요한 설정을 추가한 것.
#
## 6장. 도커 볼륨을 이용한 퍼시스턴트 스토리지
* 컨테이너의 디스크 역시 이 이미지 레이어를 순서대로 합쳐 만든 가상 파일 시스템이다.
* 모든 컨테이너는 독립된 파일 시스템을 갖는다. 같은 이미지에서 실행한 여러 개의 컨테이너는 처음에는 디스크의 내용이 모두 같지만,
  그중 한 컨테이너에서 애플리케이션이 파일을 수정해도 다른 컨테이너나 이미지는 영향을 받지 않는다.

```
docker container run --name rn1 diamol/ch06-random-number
docker container run --name rn2 diamol/ch06-random-number

docker container cp rn1:/random/number.txt number1.txt
docker container cp rn2:/random/number.txt number2.txt

cat number1.txt
cat number2.txt
```
> 같은 이미지로부터 두 개의 컨테이너 rn1과 rn2를 실행한다. 최초에 두 컨테이너는 파일 시스템의 내용이 완전히 같다.
> 두 컨테이너로부터 /random/number.txt number1.txt 파일을 로컬 컴퓨터로 복사한다. 이 파일은 컨테이너에서 생성한 것으로 서로 내용이 다르다.
> 두 컨테이너에서 복사해 온 파일의 내용을 확인한다. 실제로 파일의 내용이 다르다.
#
* 컨테이너 속 파일을 수정하면 컨테이너의 동작에 영향을 미친다. 그러나 이미지를 공유하는 다른 컨테이너나 이미지는 영향을 받지 않는다.
  수정된 파일은 해당 컨테이너의 기록 가능 레이어에만 존재하기 때문이다.
* 컨테이너가 삭제되면 이 컨테이너의 기록 가능 레이어와 여기서 수정된 데이터도 함께 삭제된다. 컨테이너의 가상 파일 시스템은 여전히 이미지 레이어와
  기록 가능 레이어로 구성되지만, 몇 가지 추가할 수 있는 요소가 더 있다. 도커 볼륨과 마운트다. 이들 요소는 컨테이너와는 별개의 생애주기를 갖는다.
  그러므로 컨테이너가 대체돼도 지속돼야 할 데이터를 저장할 수 있다.
#
### 6.2 도커 볼륨을 사용하는 컨테이너 실행하기
* 도커 볼륨은 도커에서 스토리지를 다루는 단위다. 볼륨은 컨테이너와 독립적으로 존재하며 별도의 생애주기를 갖지만, 컨테이너에 연결할 수 있다.
* 볼륨은 컨테이너 간 파일 공유보다는 업데이트 간 상태를 보존하기 위한 용도로 사용해야 하며, 이미지에서 정의하는 것보다는 명시적으로 관리하는 편이 낫다.
* 도커 볼륨이란 컨테이너 외부에 데이터를 영구 저장하는 방법이며, 컨테이너 삭제에도 데이터 유지, 공유 가능하다.
* 도커 볼륨의 장점은 컨테이너와 스토리지의 생애주기를 분리하면서도 도커를 사용하는 방식 그대로 스토리지를 다룰 수 있다는 점이다.
#
### 6.3 파일 시스템 마운트를 사용하는 컨테이너 실행하기
* 바인드 마운트란 호스트의 실제 경로를 컨테이너 내부에 연결하는 방식이다. 파일이 실시간으로 동기화된다.
  바인드 마운트는 호스트 컴퓨터 파일 시스템의 디렉터리를 컨테이너 파일 시스템의 디렉터리로 만든다.
#
### 6.5 컨테이너의 파일 시스템은 어떻게 만들어지는가?
* 모든 컨테이너는 도커가 다양한 출처로부터 모아 만든 단일 가상 디스크로 구성된 파일 시스템을 갖는다. 이 파일 시스템을 유니언 파일 시스템이라고 한다.
* 컨테이너는 유니언 파일 시스템을 통해 물리적 위치가 서로 다른 파일과 디렉터리에 마치 단일 디스크를 사용하듯 접근할 수 있다.
#
1. 기록 가능 레이어 : 비용이 비싼 계산이나 네트워크를 통해 저장해야 하는 데이터의 캐싱 등 단기 저장에 적합하다. 각 컨테이너마다 독립적인
   기록 가능 레이어를 갖지만, 컨테이너가 삭제되면 여기 저장된 데이터는 유실된다.
   
2. 로컬 바인드 마운트 : 호스트 컴퓨터와 컨테이너 간 데이터를 공유하기 위해 사용한다. 개발자의 로컬 컴퓨터에서 컨테이너로 소스 코드를 전달하기 위해
   사용하면 로컬 컴퓨터에서 수정한 내용이 이미지 빌드 없이도 즉시 컨테이너로 전달될 수 있다.
   
3. 분산 바인드 마운트 : 네트워크 스토리지와 컨테이너 간에 데이터를 공유하기 위해 사용한다. 가용성이 높지만 로컬 디스크와 비교해 지원하지 않는
   파일 시스템 기능이 있거나 성능 면에서 차이가 있을 수 있다. 읽기 전용으로 설정 파일을 전달하거나 공유 캐시로 활용할 수 있으며 읽기 쓰기 가능으로
   데이터를 저장해 동일 네트워크상의 모든 컨테이너나 컴퓨터와 데이터를 공유하는 데 적합하다.
   
4. 볼륨 마운트 : 컨테이너와 도커 객체인 볼륨 간에 데이터를 공유하기 위해 사용된다. 볼륨 마운트를 사용하면 애플리케이션이 볼륨에 데이터를 영구적으로 저장한다.
   컨테이너를 교체하는 방식으로 애플리케이션을 업데이트해도, 이전 버전 컨테이너의 데이터를 그대로 유지할 수 있다.
   
5. 이미지 레이어 : 이미지 레이어는 컨테이너의 초기 파일 시스템을 구성한다. 레이어는 적층 구조를 갖는데, 후속 레이어와 이전 레이어의 내용이 서로 충돌하는 경우
   후속 레이어의 내용이 적용된다. 레이어는 읽기 전용이며 여러 컨테이너가 공유한다.
#
## 7장. 도커 컴포즈로 분산 애플리케이션 실행하기
### 7.1 도커 컴포즈 파일의 구조
* 도커 컴포즈 파일은 애플리케이션의 '원하는 상태', 다시 말해 모든 컴포넌트가 실행 중일 때 어떤 상태여야 하는지를 기술하는 파일이다.
  도커 컴포즈 파일을 작성하고나면 도커 컴포즈 도구를 사용해 애플리케이션을 실행한다. 그러면 도커 컴포즈가 컨테이너, 네트워크, 볼륨 등 필요한
  모든 도커 객체를 만들도록 도커 API에 명령을 내린다.
#
## 8장. 헬스 체크와 디펜던시 체크로 애플리케이션의 신뢰성 확보하기
### 8.1 헬스 체크를 지원하는 도커 이미지 빌드하기
* 도커는 컨테이너를 시작할 때마다 애플리케이션의 기본적인 상태를 확인한다.
* 프로세스의 실행 상태를 확인하며 만약 프로세스가 종료됐다면 컨테이너도 종료 상태가 된다.
* 헬스체크 인스트럭션에는 도커가 컨테이너 안에서 실행하는 명령을 지정하게 되는데, 이 명령이 반환하는 상태 코드를 보고 애플리케이션의 상태를 판단한다.
#
### 8.3 애플리케이션 체크를 위한 커스텀 유틸리티 만들기
* 애플리케이션과 같은 언어로 구현된 커스텀 유틸리티의 장점은 다음과 같다.
  * 커스텀 유틸리티를 실행할 때도 애플리케이션과 같은 도구를 사용하므로 이미지에 추가적인 소프트웨어를 포함시킬 필요가 없다.
  * 재시도 횟수나 분기 등 셸 스크립트로는 표현하기 까다로운 복잡한 체크 로직을 적용할 수 있다. 특히 리눅스와 윈도 양쪽에서 사용할 크로스 플랫폼 이미지라면 더욱 유용하다.
  * 애플리케이션과 같은 설정을 사용해 대상 URL을 여러 곳에 반복 정의하거나 수정에서 누락시키는 일을 방지할 수 있다.
  * 애플리케이션과 같은 라이브러리 환경에서 데이터베이스 접속이나 인증서 파일의 존재 유무 등 컨테이너 실행 전에 확인이 필요한 모든 사항을 검증할 수 있다.

* 커스텀 테스트 유틸리티를 따로 마련하는 또 한 가지 장점은 이미지의 이식성이 향상된다는 것이다.
#
### 8.5 헬스 체크와 디펜던시 체크로 복원력 있는 애플리케이션을 만들 수 있는 이유
* 여러 개의 요소로 구성된 분산 시스템으로 동작하는 애플리케이션은 유연성과 기민성 면에서 뛰어나다. 그러나 관리가 그만큼 어려워진다.
#
## 9장. 컨테이너 모니터링으로 투명성 있는 애플리케이션 만들기
* 애플리케이션의 자동 스케일링 기능은 애플리케이션에 들어오는 트래픽 부하에 맞춰 자신의 규모를 조절하며, 간헐적인 오류에 대응해 스스로를 복원할 수 있다.
* 컨테이너에서 실행하는 애플리케이션에 있어 투명성은 매우 중요한 요소이다. 투명성을 확보하지 못하면 애플리케이션이 뭘 하고 있는지 또는 어떤 상태에 있는지,
  문제가 있다면 어떤 부분이 원인인지조차 알 수 없다.
#
### 9.1 컨테이너화된 애플리케이션에서 사용되는 모니터링 기술 스택
* 프로메테우스를 사용하면 모니터링의 중요한 측면인 일관성이 확보된다. 또한, 도커 엔진의 측정값도 같은 형식으로 추출할 수 있다는 점이다.
#
### 9.3 측정값 수집을 맡을 프로메테우스 컨테이너 실행하기
* 프로메테우스에서는 측정값을 수집하는 이 과정을 스크래핑이라고 한다.
* 레이블을 붙여 측정값에 정보를 추가하는 기능은 프로메테우스의 기능 중에서도 가장 강력한 것 중 하나다.
### 9.5 투명성의 수준
* 간단한 개념 검증 수준의 프로덕트에서 실제 서비스가 가능한 수준으로 나아가기 위해서는 투명성이 반드시 필요하다.
