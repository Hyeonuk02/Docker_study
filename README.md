# Docker_study
도커는 애플리케이션 실행 환경을 패키징하여, 어디서든 동일하게 실행할 수 있게 해주는 가상화 플랫폼이다.

## 2장. 도커의 기본적인 사용법
```
docker container run 
```
> 컨테이너로 애플리케이션을 실행하라는 도커 명령
#
**빌드** : 소스 코드를 컴파일해 실행 가능한 프로그램으로 만드는 과정  
**공유** : 이 빌드 결과물을 다른 개발자, 서버, 또는 테스트 환경에 전달하는 것  
**실행** : 공유된 빌드를 실제로 테스트하거나 배포하여 실행하는 것  

* 컨테이너를 실행할 때마다 컴퓨터 이름과 IP 주소가 매번 바뀐다.
* 컨테이너는 '격리'와 '밀집'이라는 두 가지 조건을 모두 만족시킬 수 있다. 밀집이란 컴퓨터에 CPU와 메모리가 허용하는 한 되도록
  많은 수의 애플리케이션을 실행하는 것을 의미한다. 한편, 애플리케이션은 서로 독립된 환경에서 실행돼야 한다.

* 도커를 사용하면 도구와 스크립트를 하나의 이미지로 패키징해 추가적인 설치나 설정 작업 없이 컨테이너로 스크립트를 바로 실행하게 할 수 있다.

```
docker container ls
```
> 현재 실행 중인 모든 컨테이너에 대한 정보를 볼 수 있다.
#
* 컨테이너는 종료되어도 사라지지 않는다.

- 도커를 설치하면 호스트 컴퓨터의 네트워크 계층에 도커가 끼어들게 되는데, 그러면 호스트 컴퓨터에서 들고나는 네트워크 트래픽을 모두 도커가 가로채서
  그중 필요한 것을 컨테이너에 전달할 수 있다.

* 도커 엔진은 도커의 관리 기능을 맡는 컴포넌트다. 로컬 이미지 캐시를 담당하므로 새로운 이미지가 필요하면 이미지를 내려받으며, 기존 이미지가 있다면 전에 내려받은 이미지를 사용한다.
  항시 동작하는 백그라운드 프로세스이다.

* 도커 API는 표준 HTTP 기반 REST API다. 도커 엔진의 설정을 수정하면 이 API를 네트워크를 경유해 외부 컴퓨터로부터 호출할 수 없도록 차단하거나 허용할 수 있다.
* 도커 명령행 인터페이스(도커 CLI)는 도커 API의 클라이언트다. (실제로 도커 API를 호출하는 것)

## 연습문제
* 앞서 실행해 봤던 웹 사이트 컨테이너를 실행하고 index.html 파일을 교체해 웹 페이지의 내용을 수정하는 것이다.
```
docker container run --detach --publish 8088:80 diamol/ch02-hello-diamol-web
docker container ls // container ID 확인 (0f4ad828824b)
docker exec -it 0f4ad828824b /bin/sh
```
컨테이너 안의 쉘 환경으로 접속후
```
cd /usr/local/apache2/htdocs
vi index.html
index.html 코드 수정
```
#

## 3장. 도커 이미지 만들기
* 도커 이미지는 물리적으로는 여러 개의 작은 파일로 구성돼 있다. 도커가 이들 파일을 조립해 컨테이너의 내부 파일 시스템을 만든다. 모든 레이어를 내려받고 나면
  전체 이미지를 사용할 수 있게 된다.
* --name : 지금까지 컨테이너를 조작하려면 임의로 생성된 컨테이너 ID를 입력해 대상 컨테이너를 지정해 주어야 했다. 그러나 --name 플래그를 사용하면 컨테이너에 원하는
  이름을 붙이고 이 이름으로 컨테이너를 지칭할 수 있다.

* Dockerfile은 애플리케이션을 패키징하기 위한 간단한 스크립트이다.
  1. FROM : 모든 이미지는 다른 이미지로부터 출발한다.
  2. ENV : 환경 변수 값을 지정하기 위한 인스트럭션. 값을 지정하기 위해 [key]="[value]" 형식을 따른다.
  3. WORKDIR : 컨테이너 이미지 파일 시스템에 디렉터리를 만들고, 해당 디렉터리를 작업 디렉터리로 지정하는 인스트럭션.
  4. COPY : 로컬 파일 시스템의 파일 혹은 디렉터리를 컨테이너 이미지로 복사하는 인스트럭션. [원본경로] [복사경로] 형식으로 지정하면 된다.
  5. CMD : 도커가 이미지로부터 컨테이너를 실행했을 때 실행할 명령을 지정하는 인스트럭션이다.
#
### 3.3 컨테이너 이미지 빌드하기
* 이미지를 빌드하려면 Dockerfile 스크립트 외에도 필요한 것이 몇 가지 더 있다. 이미지의 이름, 패키징에 필요한 파일의 경로를 추가로 지정해 주어야 한다.
* build 명령을 입력하면 Dockerfile 스크립트에 포함된 인스트럭션이 차례로 실행되며 그 결과가 출력된다.
#
### 3.4 도커 이미지와 이미지 레이어 이해하기
* 도커 이미지는 이미지 레이어가 모인 논리적 대상이다. 레이어는 도커 엔진의 캐시에 물리적으로 저장된 파일이다. 이미지 레이어는 여러 이미지와 컨테이너에서 공유된다.
* 도커에서 이미지 캐시의 실제 디스크 용량(물리적 용량)은 논리적 용량보다 작을 수 있다. 레이어 구조와 중복제거 기술을 활용하여 공간을 절약하기 때문이다.
  > 도커의 이미지 레이어는 여러 이미지와 컨테이너에서 공유될 수 있기 때문에, 중복되는 레이어는 디스크에 한 번만 저장되고, 그로 인해 실질적인 저장 용량은 논리적인 합계보다 더 작다.
* 이미지 레이어를 여러 이미지가 공유한다면, 공유되는 레이어는 수정할 수 없어야 한다.

### 3.5 이미지 레이어 캐시를 이용한 Dockerfile 스크립트 최적화
* Dockerfile 스크립트의 인스트럭션은 각각 하나의 이미지 레이어와 1:1로 연결된다. 그러나 인스트럭션의 결과가 이전 빌드와 같다면, 이전에 캐시된 레이어를 재사용한다.
  이런 방법으로 똑같은 인스트럭션을 다시 실행하는 낭비를 줄일 수 있다.

* 도커는 캐시에 일치하는 레이어가 있는지 확인하기 위해 해시값을 이용한다. 해시값은 Dockerfile 스크립트의 인스트럭션과 인스트럭션에 의해 복사되는 파일의 내용으로부터 계산되는데, 기존 이미지 레이어에
  해시값이 일치하는 것이 없다면 캐시 미스가 발생하고 해당 인스트럭션이 실행된다. 한 번 인스트럭션이 실행되면 그 다음에 오는 인스트럭션은 수정된 것이 없더라도 모두 실행된다.
  > 이러한 이유로 Dockerfile 스크립트의 인스트럭션은 잘 수정하지 않는 인스트럭션이 앞으로 오고 자주 수정되는 인스트럭션이 뒤에 오도록 배치돼야 한다. 이렇게 해야 캐시에 저장된 이미지 레이어를 되도록 많이 재사용할 수 있다.
